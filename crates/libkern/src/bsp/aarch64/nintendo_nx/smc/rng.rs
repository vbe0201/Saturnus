//! Implementation of random number generation based on the Secure Monitor.

use core::{mem::size_of, ptr};

use saturnus_smc::{call::*, ctx::SecureMonitorContext, result, service};

use super::call_privileged_secure_monitor_function;
use crate::{irq::ScopedInterruptDisable, sync::SpinLock};

/// The SMC *Function Identifier* for `GenerateRandomBytes`.
///
/// This function takes the number of bytes to generate as its sole argument
/// and fills `x1` through `x7` with the desired number of random bytes.
///
/// Given that only 7 registers are available, the requested number of bytes
/// must not exceed `size_of::<u64>() * 7`.
pub const GENERATE_RANDOM_BYTES: FunctionId =
    make_function_id(5, 0, service::OEM_SERVICE, true, true);

/// Defines a thread-safe interface to the [`GENERATE_RANDOM_BYTES`] Secure
/// Monitor call.
///
/// This function takes a `buf` and fills it with `buf.len()` randomly
/// generated bytes from a cryptographic RNG.
///
/// This guards the call in a critical section and ensures interrupts are
/// disabled, so it is completely safe to call this function across
/// different threads.
///
/// # Panics
///
/// Panics when `buf.len()` requests for more than the allowed number of
/// bytes as explained in the documentatin for [`GENERATE_RANDOM_BYTES`].
pub fn generate_random_bytes(buf: &mut [u8]) {
    static CRITICAL_SECTION: SpinLock<()> = SpinLock::new(());

    // The size of `GenerateRandomBytes()` output is constrained by availability
    // of usable registers so we need to make sure not to exceed this limit.
    assert!(buf.len() <= size_of::<SecureMonitorContext>() - size_of::<u64>());

    // Prepare the context for the call.
    let mut ctx = SecureMonitorContext::new()
        .function(GENERATE_RANDOM_BYTES)
        .input(0, buf.len() as u64);

    // Perform the Secure Monitor call.
    unsafe {
        let _irq_guard = ScopedInterruptDisable::start();
        let _section_token = CRITICAL_SECTION.lock();

        call_privileged_secure_monitor_function(&mut ctx);
        assert_eq!(ctx.result(), result::SUCCESS);

        // Copy the resulting bytes back to `buf`.
        ptr::copy_nonoverlapping(ctx.as_ptr(), buf.as_mut_ptr(), buf.len());
    }
}

/// Implementation of random number generation based on the Secure Monitor
/// for early kernel initialization.
///
/// These methods are not thread-safe but save overhead by avoiding costly
/// synchronization measures. These methods should only be used where it
/// is safe to guarantee thread-safety.
pub mod init {
    use core::{mem::size_of, ptr};

    use saturnus_smc::{ctx::SecureMonitorContext, result, smc, SUPERVISOR_ID};

    /// Defines an unsafe interface to the [`GENERATE_RANDOM_BYTES`] Secure
    /// Monitor call.
    ///
    /// This function takes a `buf` and fills it with `buf.len()` randomly
    /// generated bytes from a cryptographic RNG.
    ///
    /// # Safety
    ///
    /// The caller needs to ensure that only a single thread is calling this
    /// function at the same time, e.g. by only using it throughout early
    /// kernel initialization.
    ///
    /// There is no internal synchronization and neither are interrupts
    /// disabled for the duration of the call.
    ///
    /// # Panics
    ///
    /// Panics when `buf.len()` requests for more than the allowed number of
    /// bytes as explained in the documentatin for [`GENERATE_RANDOM_BYTES`].
    pub unsafe fn generate_random_bytes(buf: &mut [u8]) {
        // The size of `GenerateRandomBytes()` output is constrained by availability
        // of usable registers so we need to make sure not to exceed this limit.
        assert!(buf.len() <= size_of::<SecureMonitorContext>() - size_of::<u64>());

        // Prepare the context and perform the call.
        let mut ctx = SecureMonitorContext::new()
            .function(super::GENERATE_RANDOM_BYTES)
            .input(0, buf.len() as u64);
        smc::<SUPERVISOR_ID>(&mut ctx);
        assert_eq!(ctx.result(), result::SUCCESS);

        // Copy the resulting bytes back to `buf`.
        ptr::copy_nonoverlapping(ctx.as_ptr(), buf.as_mut_ptr(), buf.len());
    }
}
